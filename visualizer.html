<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Kuzu's Maze - Board Visualizer</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Righteous&display=swap" rel="stylesheet">
    <style>
        :root {
            --tile-size: 80px;
            --gap-size: 8px;
        }

        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background-color: #f3f4f6;
            color: #1f2937;
            line-height: 1.5;
            padding: 2rem;
            min-height: 100vh;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            border-radius: 0.75rem;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            padding: 2rem;
        }

        h1 {
            font-family: "Righteous", sans-serif;
            font-size: 2rem;
            text-align: center;
            margin-bottom: 2rem;
            color: #3b82f6;
        }

        .input-section {
            margin-bottom: 2rem;
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }

        .input-group {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }

        label {
            font-weight: 600;
            color: #374151;
        }

        textarea {
            width: 100%;
            min-height: 200px;
            padding: 1rem;
            border: 2px solid #e5e7eb;
            border-radius: 0.5rem;
            font-family: 'Courier New', monospace;
            font-size: 0.875rem;
            resize: vertical;
        }

        textarea:focus {
            outline: none;
            border-color: #3b82f6;
        }

        .button-group {
            display: flex;
            gap: 1rem;
            flex-wrap: wrap;
        }

        button {
            padding: 0.75rem 1.5rem;
            background-color: #3b82f6;
            color: white;
            border: none;
            border-radius: 0.5rem;
            font-weight: 600;
            cursor: pointer;
            transition: background-color 0.2s;
        }

        button:hover {
            background-color: #2563eb;
        }

        button.secondary {
            background-color: #6b7280;
        }

        button.secondary:hover {
            background-color: #4b5563;
        }

        .board-container {
            display: flex;
            justify-content: center;
            margin-top: 2rem;
        }

        .game-board {
            display: grid;
            grid-template-columns: repeat(4, var(--tile-size));
            grid-template-rows: repeat(5, var(--tile-size));
            gap: var(--gap-size);
            background-color: #f9fafb;
            padding: 1rem;
            border-radius: 0.75rem;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
        }

        .tile {
            width: var(--tile-size);
            height: var(--tile-size);
            border-radius: 0.5rem;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
            overflow: hidden;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            cursor: pointer;
            transition: transform 0.1s, box-shadow 0.1s, opacity 0.2s;
            padding: 0;
            border: none;
            background: none;
        }

        .tile:hover:not(.flipped):not(.disabled) {
            transform: scale(1.05);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
        }

        .tile.flipped {
            cursor: default;
        }

        .tile.disabled {
            cursor: not-allowed;
            opacity: 0.5;
        }

        .tile.current {
            outline: 4px solid #b4ed81;
            outline-offset: 2px;
        }

        .tile.valid-move {
            outline: 2px solid #3b82f6;
            outline-offset: 2px;
        }

        .tile.valid-move:hover {
            outline: 3px solid #2563eb;
        }

        .tile img {
            width: 100%;
            height: 100%;
            object-fit: cover;
            border-radius: 0.5rem;
            display: block;
        }
        
        .tile-overlay {
            position: absolute;
            top: 2px;
            left: 2px;
            background-color: rgba(0, 0, 0, 0.75);
            color: white;
            padding: 2px 6px;
            border-radius: 0.25rem;
            font-size: 0.75rem;
            font-weight: 600;
            font-family: 'Courier New', monospace;
            pointer-events: none;
            z-index: 10;
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.5);
        }

        .legend {
            margin-top: 2rem;
            padding: 1.5rem;
            background-color: #f9fafb;
            border-radius: 0.75rem;
        }

        .game-controls {
            margin-top: 2rem;
            padding: 1.5rem;
            background-color: #eff6ff;
            border-radius: 0.75rem;
            border: 2px solid #3b82f6;
        }

        .game-controls h2 {
            font-size: 1.25rem;
            margin-bottom: 1rem;
            color: #1e40af;
        }

        .game-info {
            display: flex;
            gap: 2rem;
            margin-bottom: 1rem;
            flex-wrap: wrap;
        }

        .game-info-item {
            font-size: 0.875rem;
            color: #374151;
        }

        .game-info-item strong {
            color: #1f2937;
        }
        
        .power-status {
            display: flex;
            gap: 0.5rem;
            margin-top: 0.5rem;
            flex-wrap: wrap;
        }
        
        .power-badge {
            padding: 0.25rem 0.75rem;
            border-radius: 0.375rem;
            font-size: 0.75rem;
            font-weight: 600;
            color: white;
        }
        
        .power-badge.diagonal {
            background-color: #6366f1;
        }
        
        .power-badge.extra-life {
            background-color: #ec4899;
        }
        
        .power-badge.any-order {
            background-color: #14b8a6;
        }
        
        .power-badge.warping {
            background-color: #06b6d4;
        }
        
        .power-badge.grappling {
            background-color: #a855f7;
        }

        .move-output {
            margin-top: 2rem;
            padding: 1.5rem;
            background-color: #f0fdf4;
            border-radius: 0.75rem;
            border: 2px solid #10b981;
        }

        .move-output h2 {
            font-size: 1.25rem;
            margin-bottom: 1rem;
            color: #065f46;
        }

        .move-output textarea {
            width: 100%;
            min-height: 150px;
            font-family: 'Courier New', monospace;
            font-size: 0.875rem;
            background-color: white;
            border: 1px solid #d1d5db;
        }

        .copy-button {
            margin-top: 0.5rem;
            background-color: #10b981;
        }

        .copy-button:hover {
            background-color: #059669;
        }

        .reset-button {
            background-color: #ef4444;
        }

        .reset-button:hover {
            background-color: #dc2626;
        }

        .success-message {
            padding: 1rem;
            background-color: #d1fae5;
            border: 1px solid #a7f3d0;
            border-radius: 0.5rem;
            color: #065f46;
            margin-top: 1rem;
            display: none;
        }

        .legend h2 {
            font-size: 1.25rem;
            margin-bottom: 1rem;
            color: #374151;
        }

        .legend-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 1rem;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 0.75rem;
        }

        .legend-tile {
            width: 40px;
            height: 40px;
            border-radius: 0.375rem;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-shrink: 0;
        }

        .legend-tile img {
            width: 100%;
            height: 100%;
            object-fit: fill;
            border-radius: 0.375rem;
        }

        .legend-text {
            font-size: 0.875rem;
            color: #4b5563;
        }

        .error-message {
            padding: 1rem;
            background-color: #fee2e2;
            border: 1px solid #fecaca;
            border-radius: 0.5rem;
            color: #991b1b;
            margin-top: 1rem;
            display: none;
        }

        .help-text {
            font-size: 0.875rem;
            color: #6b7280;
            margin-top: 0.5rem;
        }

        .example-buttons {
            display: flex;
            gap: 0.5rem;
            flex-wrap: wrap;
            margin-top: 0.5rem;
        }

        .example-buttons button {
            padding: 0.5rem 1rem;
            font-size: 0.875rem;
            background-color: #10b981;
        }

        .example-buttons button:hover {
            background-color: #059669;
        }

        @media (max-width: 640px) {
            :root {
                --tile-size: 60px;
                --gap-size: 6px;
            }

            .container {
                padding: 1rem;
            }

            h1 {
                font-size: 1.5rem;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>ðŸŽ® Kuzu's Maze - Board Visualizer</h1>
        
        <div class="input-section">
            <div class="input-group">
                <label for="boardInput">Board Configuration (5 rows Ã— 4 columns)</label>
                <p class="help-text">
                    Enter your board as a JSON array. Each row should have 4 values (0-11).
                </p>
                <div class="example-buttons">
                    <button onclick="loadExample1()">Load Example 1</button>
                    <button onclick="loadExample2()">Load Example 2</button>
                    <button onclick="loadRandomBoard()">Generate Random</button>
                </div>
                <textarea id="boardInput" placeholder='[
  [7, 11, 0, 0],
  [9, 1, 11, 0],
  [2, 4, 11, 11],
  [5, 6, 0, 3],
  [10, 8, 0, 0]
]'></textarea>
            </div>
            
            <div class="button-group">
                <button onclick="visualizeBoard()">Visualize Board</button>
                <button class="secondary" onclick="clearBoard()">Clear</button>
            </div>
            
            <div id="errorMessage" class="error-message"></div>
        </div>

        <div class="board-container">
            <div class="game-board" id="gameBoard">
                <!-- Board tiles will be generated here -->
            </div>
        </div>

        <div class="game-controls" id="gameControls" style="display: none;">
            <h2>ðŸŽ® Game Controls</h2>
            <div class="game-info">
                <div class="game-info-item">
                    <strong>Current Position:</strong> <span id="currentPosition">None</span>
                </div>
                <div class="game-info-item">
                    <strong>Moves Made:</strong> <span id="moveCount">0</span>
                </div>
                <div class="game-info-item">
                    <strong>Tiles Flipped:</strong> <span id="tilesFlipped">0</span>
                </div>
                <div class="game-info-item">
                    <strong>Next Goal:</strong> <span id="nextGoal">1</span>
                </div>
            </div>
            <div class="power-status" id="powerStatus"></div>
            <div class="button-group">
                <button class="reset-button" onclick="resetGame()">Reset Game</button>
                <button class="secondary" onclick="undoMove()">Undo Last Move</button>
            </div>
        </div>

        <div class="move-output" id="moveOutput" style="display: none;">
            <h2>ðŸ“‹ Solution Object (Copy this!)</h2>
            <p style="font-size: 0.875rem; color: #6b7280; margin-bottom: 0.5rem;">
                Ready to paste into your boards.json file
            </p>
            <textarea id="movePathOutput" readonly></textarea>
            <button class="copy-button" onclick="copyMoves()">Copy Solution</button>
            <div id="successMessage" class="success-message"></div>
        </div>

        <div class="legend">
            <h2>Tile Legend</h2>
            <div class="legend-grid">
                <div class="legend-item">
                    <div class="legend-tile"><img src="src/walkthrough.svg" alt="0"></div>
                    <div class="legend-text"><strong>0:</strong> Stepping Stone</div>
                </div>
                <div class="legend-item">
                    <div class="legend-tile"><img src="src/flower1.svg" alt="1"></div>
                    <div class="legend-text"><strong>1:</strong> Flower 1</div>
                </div>
                <div class="legend-item">
                    <div class="legend-tile"><img src="src/flower2.svg" alt="2"></div>
                    <div class="legend-text"><strong>2:</strong> Flower 2</div>
                </div>
                <div class="legend-item">
                    <div class="legend-tile"><img src="src/flower3.svg" alt="3"></div>
                    <div class="legend-text"><strong>3:</strong> Flower 3</div>
                </div>
                <div class="legend-item">
                    <div class="legend-tile"><img src="src/flower4.svg" alt="4"></div>
                    <div class="legend-text"><strong>4:</strong> Flower 4</div>
                </div>
                <div class="legend-item">
                    <div class="legend-tile"><img src="src/flower5.svg" alt="5"></div>
                    <div class="legend-text"><strong>5:</strong> Flower 5</div>
                </div>
                <div class="legend-item">
                    <div class="legend-tile"><img src="src/grapple.svg" alt="6"></div>
                    <div class="legend-text"><strong>6:</strong> Grapple</div>
                </div>
                <div class="legend-item">
                    <div class="legend-tile"><img src="src/extralife.svg" alt="7"></div>
                    <div class="legend-text"><strong>7:</strong> Spray (Extra Life)</div>
                </div>
                <div class="legend-item">
                    <div class="legend-tile"><img src="src/diagonal.svg" alt="8"></div>
                    <div class="legend-text"><strong>8:</strong> Shears (Diagonal)</div>
                </div>
                <div class="legend-item">
                    <div class="legend-tile"><img src="src/ooflower.svg" alt="9"></div>
                    <div class="legend-text"><strong>9:</strong> Flower Power</div>
                </div>
                <div class="legend-item">
                    <div class="legend-tile"><img src="src/warp.svg" alt="10"></div>
                    <div class="legend-text"><strong>10:</strong> Portal (Warp)</div>
                </div>
                <div class="legend-item">
                    <div class="legend-tile"><img src="src/death.svg" alt="11"></div>
                    <div class="legend-text"><strong>11:</strong> Vine Monster (Death)</div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Game state
        let currentBoard = null;
        let currentPosition = null;
        let flippedTiles = new Set();
        let movePath = [];
        let isPlaying = false;
        let powersUsed = new Set();
        
        // Game mechanics
        let canMoveDiagonal = false;
        let hasExtraLife = false;
        let canSelectAnyGoal = false;
        let isWarping = false;
        let isGrappling = false;
        let grapplePosition = null;
        let nextGoalTile = 1;
        let collectedGoals = new Set();

        function getTileImage(value) {
            const images = {
                0: 'src/walkthrough.svg',
                1: 'src/flower1.svg',
                2: 'src/flower2.svg',
                3: 'src/flower3.svg',
                4: 'src/flower4.svg',
                5: 'src/flower5.svg',
                6: 'src/grapple.svg',
                7: 'src/extralife.svg',
                8: 'src/diagonal.svg',
                9: 'src/ooflower.svg',
                10: 'src/warp.svg',
                11: 'src/death.svg',
                'unflipped': 'src/unflipped.svg'
            };
            return images[value] || 'src/unflipped.svg';
        }

        function showError(message) {
            const errorDiv = document.getElementById('errorMessage');
            errorDiv.textContent = message;
            errorDiv.style.display = 'block';
        }

        function hideError() {
            const errorDiv = document.getElementById('errorMessage');
            errorDiv.style.display = 'none';
        }

        function showSuccess(message) {
            const successDiv = document.getElementById('successMessage');
            successDiv.textContent = message;
            successDiv.style.display = 'block';
            setTimeout(() => {
                successDiv.style.display = 'none';
            }, 3000);
        }

        function validateBoard(board) {
            if (!Array.isArray(board)) {
                return 'Board must be an array';
            }
            
            if (board.length !== 5) {
                return `Board must have exactly 5 rows (found ${board.length})`;
            }
            
            for (let i = 0; i < board.length; i++) {
                if (!Array.isArray(board[i])) {
                    return `Row ${i + 1} must be an array`;
                }
                
                if (board[i].length !== 4) {
                    return `Row ${i + 1} must have exactly 4 columns (found ${board[i].length})`;
                }
                
                for (let j = 0; j < board[i].length; j++) {
                    const value = board[i][j];
                    if (!Number.isInteger(value) || value < 0 || value > 11) {
                        return `Invalid value ${value} at row ${i + 1}, column ${j + 1}. Must be 0-11`;
                    }
                }
            }
            
            return null;
        }

        function isValidMove(row, col) {
            // If warping, can select any unflipped tile
            if (isWarping) {
                return !flippedTiles.has(`${row}-${col}`);
            }
            
            // If grappling, can select any unflipped tile (stays on grapple tile after)
            if (isGrappling) {
                return !flippedTiles.has(`${row}-${col}`);
            }
            
            // If no position set, can only start from edges
            if (currentPosition === null) {
                const lastRow = currentBoard.length - 1;
                const lastCol = currentBoard[0].length - 1;
                return (row === 0 || row === lastRow) || (col === 0 || col === lastCol);
            }

            const [currentRow, currentCol] = currentPosition;
            
            // Check if orthogonally adjacent
            const orthogonal = (
                (Math.abs(row - currentRow) === 1 && col === currentCol) ||
                (Math.abs(col - currentCol) === 1 && row === currentRow)
            );
            
            // Check if diagonally adjacent (if diagonal movement enabled)
            const diagonal = canMoveDiagonal && (
                Math.abs(row - currentRow) === 1 && Math.abs(col - currentCol) === 1
            );

            // Can move to unflipped tiles or stepping stones (value 0)
            const canMoveToTile = !flippedTiles.has(`${row}-${col}`) || 
                                 (flippedTiles.has(`${row}-${col}`) && currentBoard[row][col] === 0);

            return (orthogonal || diagonal) && canMoveToTile;
        }

        function updateGameInfo() {
            if (currentPosition) {
                const [row, col] = currentPosition;
                document.getElementById('currentPosition').textContent = `Row ${row + 1}, Col ${col + 1}`;
            } else {
                document.getElementById('currentPosition').textContent = 'None (Click an edge tile to start)';
            }
            
            document.getElementById('moveCount').textContent = movePath.length;
            document.getElementById('tilesFlipped').textContent = flippedTiles.size;
            document.getElementById('nextGoal').textContent = nextGoalTile <= 5 ? nextGoalTile : 'Complete!';
            
            // Update power status display
            const powerStatus = document.getElementById('powerStatus');
            powerStatus.innerHTML = '';
            
            if (canMoveDiagonal) {
                const badge = document.createElement('div');
                badge.className = 'power-badge diagonal';
                badge.textContent = 'âœ‚ï¸ Diagonal Movement';
                powerStatus.appendChild(badge);
            }
            
            if (hasExtraLife) {
                const badge = document.createElement('div');
                badge.className = 'power-badge extra-life';
                badge.textContent = 'ðŸ’š Extra Life';
                powerStatus.appendChild(badge);
            }
            
            if (canSelectAnyGoal) {
                const badge = document.createElement('div');
                badge.className = 'power-badge any-order';
                badge.textContent = 'ðŸŒ¸ Any Order';
                powerStatus.appendChild(badge);
            }
            
            if (isWarping) {
                const badge = document.createElement('div');
                badge.className = 'power-badge warping';
                badge.textContent = 'ðŸŒ€ Warping';
                powerStatus.appendChild(badge);
            }
            
            if (isGrappling) {
                const badge = document.createElement('div');
                badge.className = 'power-badge grappling';
                badge.textContent = 'ðŸª Grappling';
                powerStatus.appendChild(badge);
            }
            
            // Update move output in solution format
            if (movePath.length > 0) {
                const solutionObject = {
                    tiles_flipped: flippedTiles.size,
                    powers_used: Array.from(powersUsed).sort((a, b) => a - b),
                    path: movePath
                };
                
                // Custom JSON formatting to match exact style
                let output = '{\n';
                output += '      "tiles_flipped": ' + solutionObject.tiles_flipped + ',\n';
                output += '"powers_used": ' + JSON.stringify(solutionObject.powers_used) + ',\n';
                output += '"path": [\n';
                
                // Format path with specific indentation
                solutionObject.path.forEach((coord, index) => {
                    const isLast = index === solutionObject.path.length - 1;
                    output += '        ' + JSON.stringify(coord);
                    if (!isLast) {
                        output += ',';
                    }
                    output += '\n';
                });
                
                output += '  ]\n';
                output += '    }';
                
                document.getElementById('movePathOutput').value = output;
                document.getElementById('moveOutput').style.display = 'block';
            }
        }

        function handleTileEffect(row, col, tileValue, isGrappleEffect = false) {
            // Handle flowers (1-5)
            if (tileValue >= 1 && tileValue <= 5) {
                if (canSelectAnyGoal || tileValue === nextGoalTile) {
                    collectedGoals.add(tileValue);
                    
                    // Refill extra life if it was used
                    if (hasExtraLife === false && tileValue === nextGoalTile) {
                        hasExtraLife = true;
                    }
                    
                    if (canSelectAnyGoal) {
                        const remainingGoals = new Set([1, 2, 3, 4, 5]);
                        collectedGoals.forEach(value => {
                            remainingGoals.delete(value);
                        });
                        nextGoalTile = Math.min(...remainingGoals);
                        canSelectAnyGoal = false;
                    } else {
                        nextGoalTile++;
                    }
                    
                    if (collectedGoals.size === 5) {
                        // Victory! All flowers collected
                        return true;
                    }
                } else {
                    // Wrong order
                    return true;
                }
            }
            
            // Handle grapple (6) - but not if this IS a grapple effect
            if (tileValue === 6 && !isGrappleEffect) {
                powersUsed.add(6);
                isGrappling = true;
                grapplePosition = [row, col];
                return false;
            }
            
            // Handle other power-ups
            switch (tileValue) {
                case 7: // Extra Life
                    powersUsed.add(7);
                    hasExtraLife = true;
                    break;
                    
                case 8: // Diagonal
                    powersUsed.add(8);
                    canMoveDiagonal = true;
                    break;
                    
                case 9: // Any Order
                    powersUsed.add(9);
                    canSelectAnyGoal = true;
                    break;
                    
                case 10: // Warp
                    powersUsed.add(10);
                    if (!isGrappleEffect) {
                        isWarping = true;
                    } else {
                        isGrappling = false;
                        isWarping = true;
                    }
                    break;
                    
                case 11: // Death
                    if (hasExtraLife) {
                        hasExtraLife = false;
                        // Extra life used
                    } else {
                        // Death tile hit
                        return true;
                    }
                    break;
            }
            
            return false;
        }

        async function handleTileClick(row, col) {
            if (!isPlaying || !isValidMove(row, col)) {
                return;
            }

            const tileValue = currentBoard[row][col];
            
            // Add to move path
            movePath.push([row, col]);
            
            // Mark as flipped
            flippedTiles.add(`${row}-${col}`);
            
            // Handle warping
            if (isWarping) {
                isWarping = false;
                currentPosition = [row, col];
                handleTileEffect(row, col, tileValue);
                renderBoard(currentBoard, true);
                updateGameInfo();
                return;
            }
            
            // Handle grappling
            if (isGrappling) {
                const [currentRow, currentCol] = currentPosition;
                const isAdjacent = 
                    (Math.abs(row - currentRow) === 1 && col === currentCol) ||
                    (Math.abs(col - currentCol) === 1 && row === currentRow) ||
                    (canMoveDiagonal && 
                     Math.abs(row - currentRow) === 1 && 
                     Math.abs(col - currentCol) === 1);
                
                // Grapple flips the tile but player stays on grapple tile
                const shouldEnd = handleTileEffect(row, col, tileValue, true);
                
                // After grappling, always return to grapple position
                if (!shouldEnd) {
                    currentPosition = grapplePosition;
                }
                
                isGrappling = false;
                grapplePosition = null;
                
                renderBoard(currentBoard, true);
                updateGameInfo();
                return;
            }
            
            // Normal move
            currentPosition = [row, col];
            handleTileEffect(row, col, tileValue);
            
            // Re-render to update valid moves
            renderBoard(currentBoard, true);
            
            // Update game info
            updateGameInfo();
        }

        function renderBoard(board, keepState = false) {
            const gameBoard = document.getElementById('gameBoard');
            gameBoard.innerHTML = '';
            
            if (!keepState) {
                // Reset game state
                currentPosition = null;
                flippedTiles.clear();
                movePath = [];
            }
            
            board.forEach((row, rowIndex) => {
                row.forEach((value, colIndex) => {
                    const tile = document.createElement('button');
                    tile.className = 'tile';
                    tile.setAttribute('data-position', `${rowIndex}-${colIndex}`);
                    
                    // Just show the tile value directly - no flipping animation needed
                    const img = document.createElement('img');
                    img.src = getTileImage(value);
                    img.alt = `Tile ${value}`;
                    tile.appendChild(img);
                    
                    // Add coordinate overlay
                    const overlay = document.createElement('div');
                    overlay.className = 'tile-overlay';
                    overlay.textContent = `[${rowIndex},${colIndex}]`;
                    tile.appendChild(overlay);
                    
                    // Mark current position
                    if (currentPosition && currentPosition[0] === rowIndex && currentPosition[1] === colIndex) {
                        tile.classList.add('current');
                    }
                    
                    // Mark valid moves
                    if (isPlaying && isValidMove(rowIndex, colIndex) && !flippedTiles.has(`${rowIndex}-${colIndex}`)) {
                        tile.classList.add('valid-move');
                    }
                    
                    // Mark flipped tiles (for visual feedback)
                    if (flippedTiles.has(`${rowIndex}-${colIndex}`)) {
                        tile.classList.add('flipped');
                        tile.style.opacity = '0.7';
                    }
                    
                    // Add click handler
                    tile.onclick = () => handleTileClick(rowIndex, colIndex);
                    
                    gameBoard.appendChild(tile);
                });
            });
            
            updateGameInfo();
        }

        function visualizeBoard() {
            hideError();
            
            const input = document.getElementById('boardInput').value.trim();
            
            if (!input) {
                showError('Please enter a board configuration');
                return;
            }
            
            let board;
            try {
                board = JSON.parse(input);
            } catch (e) {
                showError('Invalid JSON format. Please check your syntax.');
                return;
            }
            
            const validationError = validateBoard(board);
            if (validationError) {
                showError(validationError);
                return;
            }
            
            currentBoard = board;
            isPlaying = true;
            renderBoard(board);
            
            // Show game controls
            document.getElementById('gameControls').style.display = 'block';
        }

        function resetGame() {
            if (!currentBoard) return;
            
            currentPosition = null;
            flippedTiles.clear();
            movePath = [];
            powersUsed.clear();
            
            // Reset game mechanics
            canMoveDiagonal = false;
            hasExtraLife = false;
            canSelectAnyGoal = false;
            isWarping = false;
            isGrappling = false;
            grapplePosition = null;
            nextGoalTile = 1;
            collectedGoals.clear();
            
            renderBoard(currentBoard, false);
            updateGameInfo();
            
            document.getElementById('moveOutput').style.display = 'none';
        }

        function undoMove() {
            if (movePath.length === 0) return;
            
            // Remove last move
            const lastMove = movePath.pop();
            const [row, col] = lastMove;
            
            // Only remove from flippedTiles if it's not a stepping stone (0)
            // or if we haven't moved through it multiple times
            const moveCount = movePath.filter(m => m[0] === row && m[1] === col).length;
            if (moveCount === 0 && currentBoard[row][col] !== 0) {
                flippedTiles.delete(`${row}-${col}`);
            }
            
            // Update current position to previous move, or null if no moves left
            if (movePath.length > 0) {
                currentPosition = movePath[movePath.length - 1];
            } else {
                currentPosition = null;
            }
            
            renderBoard(currentBoard, true);
            updateGameInfo();
        }

        function copyMoves() {
            const output = document.getElementById('movePathOutput');
            output.select();
            document.execCommand('copy');
            
            // Try modern clipboard API
            try {
                navigator.clipboard.writeText(output.value);
            } catch (e) {
                console.log('Fallback copy used');
            }
            
            showSuccess('Solution object copied to clipboard!');
        }

        function clearBoard() {
            document.getElementById('boardInput').value = '';
            document.getElementById('gameBoard').innerHTML = '';
            document.getElementById('gameControls').style.display = 'none';
            document.getElementById('moveOutput').style.display = 'none';
            hideError();
            
            currentBoard = null;
            currentPosition = null;
            flippedTiles.clear();
            movePath = [];
            powersUsed.clear();
            isPlaying = false;
            
            // Reset game mechanics
            canMoveDiagonal = false;
            hasExtraLife = false;
            canSelectAnyGoal = false;
            isWarping = false;
            isGrappling = false;
            grapplePosition = null;
            nextGoalTile = 1;
            collectedGoals.clear();
        }

        function loadExample1() {
            const example = [
                [7, 11, 0, 0],
                [9, 1, 11, 0],
                [2, 4, 11, 11],
                [5, 6, 0, 3],
                [10, 8, 0, 0]
            ];
            document.getElementById('boardInput').value = JSON.stringify(example, null, 2);
            visualizeBoard();
        }

        function loadExample2() {
            const example = [
                [1, 2, 3, 4],
                [5, 6, 7, 8],
                [9, 10, 11, 0],
                [0, 0, 11, 11],
                [11, 11, 0, 0]
            ];
            document.getElementById('boardInput').value = JSON.stringify(example, null, 2);
            visualizeBoard();
        }

        function loadRandomBoard() {
            // Create a random board with proper distribution
            const tiles = [
                ...Array(6).fill(0),  // 6 Stepping stones
                1, 2, 3, 4, 5,        // 5 Flowers
                6, 7, 8, 9, 10,       // 5 Power-ups
                ...Array(4).fill(11)  // 4 Death tiles
            ];
            
            // Fisher-Yates shuffle
            for (let i = tiles.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [tiles[i], tiles[j]] = [tiles[j], tiles[i]];
            }

            // Create 5x4 board
            const board = [];
            for (let i = 0; i < 5; i++) {
                board.push(tiles.slice(i * 4, (i + 1) * 4));
            }

            document.getElementById('boardInput').value = JSON.stringify(board, null, 2);
            visualizeBoard();
        }

        // Load example 1 on page load
        window.addEventListener('load', () => {
            loadExample1();
        });
    </script>
</body>
</html>